# 初始化和清理

初始化，构造器。没创建一个对象，这个方法就会被自动调用。
清理： Garbage Collector

```java
class Rock {
    Rock(){ // 这是一个构造器
        
    }
}
```
创建对象时，内存被分配，构造器被调用。无参和有参
方法重载，根据参数不一样，执行不同的逻辑
在java中构造器的方法名是一样的，只能利用方法重载

### this 关键字

this关键在只能在非静态方法内部使用。
不需要显式使用，编译器会帮你处理。 链式调用，或者把当前对象传递给别的对象调用时使用this

在构造器中调用构造器,此时this指向构造器方法
```java
this(param1,param2)
```

### staic 的含义

static方法是为类而创建的，不需要任何对象。看起来就像全局方法。如果你发现代码中出现了大量的static方法，就该重新考虑自己的设计了。

## 垃圾回收器

java中有垃圾回收器，回收无用对象占用的内存。你创建的对象不是通过new来分配内存的，而垃圾回收器只知道如何释放用new创建的内存。为了处理这种情况，java允许在类中定义名为finalize的方法

当垃圾回收器准备回收对象的内存时，首先会调用其finalize方法，并在下一轮的垃圾回收动作发生时，才会真正回收对象占用的内存。 finalize是一个潜在的编程陷阱： 不是C++中的析构函数（C++销毁对象是会调用这个函数）
1. 对象可能不被垃圾回收。
2. 垃圾回收不等同于析构。

finalize的用户
垃圾回收要记住的第三点:
垃圾回收只与内存有关
所以finalize函数也用来处理和内存有关的逻辑，处理本地函数调用中涉及到内存的部分，java中万物接对象，不存在不是对象分配的内存。但是在本地函数调用中有c,c++的调用，二者也可以调用其他的函数。所以该方式是再对象被回收时，进行相关的内存操作。

实施清理
垃圾回收器会帮你清理。
无论是垃圾回收还是终结，都不保证一定会发生。如果Java虚拟机JVM并未面临内存耗尽的情形，他可能不会浪费时间进行垃圾回收以回复内存。

终结条件

finalize 还有一个有趣的用法，不依赖于每次都要对finalize进行调用，这就是对对象终结条件的验证。
对象代表了一个打开的文件，在对象被垃圾回收之前，程序员应该关闭这个文件。只要对象中存在没有被适当清理的部分，程序句存在很隐晦的bug。

垃圾回收器如何工作

在堆上分配内存的代价十分高昂。java中垃圾回收器很明显的提高对象的创建速度。java从对空间分配的速度可以与其他语言在栈上分配空间的速度相媲美。
垃圾回收器工作时，一边回收内存，一边是堆中的对象紧凑排列，这样堆指针就可以很容易的移动到更靠近传送带的开始处，避免了内存页面的调度。垃圾回收器通过重新排列对象，实现了一种高速的，有无限分配空间的堆模型。

引用计数的方式回收。常用来说明不过未被应用于任何一种java虚拟机中，引用计数的循环引用

另一种方式：
对于任意"活"的对象，一定能最终追溯到其存活在栈活静态存储区中的引用。这个引用链条可能会穿过数个对象层次，，由此，如果从栈或静态存储区出发，遍历所有引用，你将会发现所有"活"的对象。递归的查找

在这种方式下，java虚拟机采用一种自适应的垃圾回收技术， 停止-复制。先暂停程序的运行，然后将所有存活的对象从当前堆复制到另一个堆，没有复制的就是需要被垃圾回收的。被复制到新堆时，可以紧密排列。

停止-复制的方式的缺点和优化？
效率地下： 原因1. 得有两个堆，在两个堆之间来回折腾，得维护比实际需要大一倍的空间。 通过在堆中分配几块比较大的内存，复制动作在这些大的内存块中完成
原因2： 复制本身。 程序进入稳定状态后，可能只会产生少量的垃圾。尽管如此，复制回收器仍然会将所有内存从一处复制到另一处，这很浪费。  优化： 如果没有新垃圾产生， 就会转换到另一种方式。 标记-清扫 mark-and-sweep

标记清扫 给关联的活的对象打上标记，剩下的被释放，不会复制。清扫后的堆是不连续的，如果希望连续，需要重新整理剩下的对象。

垃圾回收动作发生的同时，程序将会暂停。
“如前文所述，这里讨论的 Java 虚拟机中，内存分配以较大的"块"为单位。如果对象较大，它会占用单独的块。严格来说，"停止-复制"要求在释放旧对象之前，必须先将所有存活对象从旧堆复制到新堆，这导致了大量的内存复制行为。有了块，垃圾回收器就可以把对象复制到废弃的块。每个块都有年代数来记录自己是否存活。通常，如果块在某处被引用，其年代数加 1，垃圾回收器会对上次回收动作之后新分配的块进行整理。这对处理大量短命的临时对象很有帮助。垃圾回收器会定期进行完整的清理动作——大型对象仍然不会复制（只是年代数会增加），含有小型对象的那些块则被复制并整理。Java 虚拟机会监视，如果所有对象都很稳定，垃圾回收的效率降低的话，就切换到"标记-清扫"方式。同样，Java 虚拟机会跟踪"标记-清扫"的效果，如果堆[…]”

自适应的、分代的，停止-复制、标记-清扫式的垃圾回收器。

java虚拟机中有许多附加技术用来提升速度。 尤其是与加载器操作有关的，被称为"即时"编译器技术 Just-In-Tim JIT

这种技术可以把程序全布活部分翻译为本地机器码，所以不需要JVM来进行翻译，因此运行的更快。
可以让编译器编译所有的代码，有缺点， 编译需要时间；可执行代码长度要比字节码长
惰性评估 编译器在需要时才去编译代码。

## 成员初始化

基本类型初始化
引用类型初始化

## 指定初始化
显式调用initValue方法
## 构造器初始化
在构造方法中，初始话成员。但是也不会替代成员初始化。
成员初始化必然会调用，保证了成员的初始正确

## 静态数据的初始化

# 创建对象的过程，假设有个名为Dog的类：

1. 即使没有显示使用static关键字，构造器实际上也是静态方法。所以，当首次创建Dog类型的对象或是首次访问Dog类的静态方法活属性时，Java解释器必须在类路径中查找，以定位Dog。class
2. 当加载完Dog.class后，有关静态初始化的所有动作都会执行。因此，静态初始化，只会在首次加载Class对象时初始化一次。
3. 当用 new Dog()创建对象时，首先会在堆上位Dog对象分配足够的存储空间。
4. 分配的存储空间首先会被清零，即会将Dog对象中的所有基本类型数据设置为默认值（数字会被置为0，布尔型和字符型也相同），应用被置为null。
5. 执行所有出现在字段定义处的初始化动作
6. 执行构造器。你将会在"复用"这一章看到，这可能会牵扯到很多动作，尤其当涉及继承的时候。

## 显式静态的代码区块

## 非静态实例初始化
也是在构造之前执行的。 匿名内部类的时候使用

## 数组初始化

定义数组

int[] a1;
int a1[]; c和c++程序员习惯

在初始数组的时候，确定长度，分配内存

java不允许对数组进行越界访问。不想c和c++

## 动态创建数组

可以通过字符表达式的方式创建数组，也可以通过new 来创建。

## 可变参数列表

类似于 rest 参数

```java
    static void printArray(Object[] args) {
static void printArray(Object... args) { // 可变参数列表

```
可变参数，无须显式的别写数组语法了

## 枚举类型

```java
public enum Spiciness {
    NOT,MILD,MEDIUM,HOT,FLAMING
}
```




