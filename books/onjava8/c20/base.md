# 泛型

帮助编写的对象适用于"非特定的类型"，而不是一个具体的接口或类



### 泛型接口


泛型的局限性： 基本类型无法作为泛型的类型参数。

### 泛型方法

泛型类和泛型方法之间的关系？

泛型方法独立于泛型类的改变，请"尽可能"的使用泛型方法。通常将单个方法泛型化比将整个类泛型化更清晰易懂。

如果方法是static的，则无法访问该类的泛型类型参数，

要定义泛型方法，请将泛型参数列表放置在返回值之前。

对于泛型类，必须在实例化该类时指定类型参数。使用泛型方法是，通常不需要指定参数类型，因为编译器会找出这些类型。这称为类型参数推断。
如果使用基本类型调用f(), 自动装箱就开始起作用。自动将基本类型包装在它们对应的包装类型中。

### 变长参数和泛型方法

### 简化元祖的使用

## 泛型擦除

getTypeParameters() 返回一个TypeVariable对象数组。

Java泛型是使用擦除实现的。意味着你在使用泛型时，任何具体的类型信息都被擦出了，你唯一知道的就是你在使用一个对象。

### C++的方式


因为擦除，Java编译器无法将manipulate()方法必须能调用obj的f()方法这一需求映射到HasF具有f()方法这个事实上。为了调用f()，必须协助泛型类，给定泛型类一个边界，以此告诉编译器只能接受遵循这个边界的类型。使用关键字extends, 生命T是HasF类型或其子列。

```java
public class Manipulator2 <T extends HasF>{
    
}
```

### 迁移兼容性

为了减少潜在的关于擦除的困惑，这不是一个语言特性。它是Java实现泛型的一种妥协，因为泛型不是Java出现时就有的。泛型在Java中仍然是有用的，只是不如它们在本来设想的那么有用，而原因就是擦除。

在基于擦除的实现中，泛型类型被当做第二类的类型处理。即不能再某些重要的上下文中使用泛型类型。泛型类型只有在静态检测中出现，在此之后，程序中的所有泛型类型都将被擦除，替换为他们的非泛型上限。例如： List<T>被擦除为List,普通的类型变量在未指定边界的情况下会被擦除为Object。

为什么要擦除？

为了向后兼容，老的代码没有使用泛型，有可能一直不进行使用泛型的更新。非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下将泛型融入到语言中。


带来了什么问题？

擦除的代价是显著的。泛型不能用于显式的引用运行时类型的操作中，例如转型，InstanceOf操作和new 表达式。因为素有关于参数的类型信息都丢失了。当你编写泛型代码时，必须时刻提醒自己，你只是看起来拥有有关参数的类型信息而已。


### 补偿擦除

因为擦除，失去执行泛型代码中某些操作的能力。无法在运行时知道确切的类型， 有时可以有一些方法解决，有时必须通过引入类型标签来补偿擦除。

无法进行 new T()操作，因为无法判断是否有无参构造。

## 边界

唯一没有限制的泛型中的方法是哪些Object中的方法，如果将参数类型限制为某类型的子集，则可以调用该子集中的方法。
```java
class Demo <T extends  A &B>{}
```

## 通配符

泛型的主要目标之一是将这种错误检测移到编译期。

```java
Fruit[] fruit = new Apple[10];
fruit[0] = new Apple();
fruit[1] = new Jonathan();
try{
    fruit[0] = new Fruit();
        }catch(Exception e){
    
        }

        try{
        fruit[0] = new Orange();
        }catch(Exception e){

        }
```
